// Copyright (C) 2009-2020, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki start comp
#include <shaders/Common.glsl>

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant, std430) uniform pc_
{
	UVec2 u_level0WriteImgSize;
	UVec2 u_level1WriteImgSize;
	U32 u_copyToClientLevel;
	U32 u_writeLevel1;
	U32 u_padding0;
	U32 u_padding1;
};

layout(set = 0, binding = 0) uniform sampler u_nearestAnyClampSampler;
layout(set = 0, binding = 1) uniform texture2D u_minReadTex;
layout(set = 0, binding = 2) uniform texture2D u_maxReadTex;
layout(set = 0, binding = 3) writeonly uniform image2D u_minLevel0WriteImg;
layout(set = 0, binding = 4) writeonly uniform image2D u_maxLevel0WriteImg;
layout(set = 0, binding = 5) writeonly uniform image2D u_minLevel1WriteImg;
layout(set = 0, binding = 6) writeonly uniform image2D u_maxLevel1WriteImg;

layout(std430, set = 0, binding = 7) writeonly buffer b_clientBuf
{
	F32 u_clientBuf[];
};

shared Vec2 s_depths[gl_WorkGroupSize.y][gl_WorkGroupSize.x];

// Resolve depths into one value
Vec2 resolveDepths(Vec4 minDepths, Vec4 maxDepths)
{
	const Vec2 mind2 = min(minDepths.xy, maxDepths.zw);
	const F32 mind = min(mind2.x, mind2.y);

	const Vec2 maxd2 = max(maxDepths.xy, maxDepths.zw);
	const F32 maxd = max(maxd2.x, maxd2.y);

	return Vec2(mind, maxd);
}

void main()
{
	// Read depth
	const Vec2 readUv = (Vec2(gl_GlobalInvocationID.xy) + 0.5) / Vec2(u_level0WriteImgSize);
	Vec4 minDepths = textureGather(sampler2D(u_minReadTex, u_nearestAnyClampSampler), readUv, 0);
	Vec4 maxDepths = textureGather(sampler2D(u_maxReadTex, u_nearestAnyClampSampler), readUv, 0);

	// Resolve & store the 1st level
	Vec2 depths = resolveDepths(minDepths, maxDepths);
	s_depths[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = depths;

	if(all(lessThan(gl_GlobalInvocationID.xy, u_level0WriteImgSize)))
	{
		imageStore(u_minLevel0WriteImg, IVec2(gl_GlobalInvocationID.xy), Vec4(depths.x));
		imageStore(u_maxLevel0WriteImg, IVec2(gl_GlobalInvocationID.xy), Vec4(depths.y));

		if(u_copyToClientLevel == 0u)
		{
			const U32 idx = gl_GlobalInvocationID.y * u_level0WriteImgSize.x + gl_GlobalInvocationID.x;
			u_clientBuf[idx] = depths.y;
		}
	}

	// Early exit
	if(u_writeLevel1 == 0u)
	{
		return;
	}

	// Sync
	memoryBarrierShared();
	barrier();

	// Resolve 2nd level
	if(all(equal(gl_LocalInvocationID.xy & UVec2(1u), UVec2(0u))))
	{
		const U32 i0 = gl_LocalInvocationID.x;
		const U32 i1 = i0 + 1u;
		const U32 j0 = gl_LocalInvocationID.y;
		const U32 j1 = j0 + 1u;

		minDepths.x = depths.x;
		minDepths.y = s_depths[j0][i1].x;
		minDepths.z = s_depths[j1][i1].x;
		minDepths.w = s_depths[j1][i0].x;

		maxDepths.x = depths.y;
		maxDepths.y = s_depths[j0][i1].y;
		maxDepths.z = s_depths[j1][i1].y;
		maxDepths.w = s_depths[j1][i0].y;

		depths = resolveDepths(minDepths, maxDepths);

		const UVec2 writeUv = gl_GlobalInvocationID.xy >> 1u;
		if(all(lessThan(writeUv, u_level1WriteImgSize)))
		{
			imageStore(u_minLevel1WriteImg, IVec2(writeUv), Vec4(depths.x));
			imageStore(u_maxLevel1WriteImg, IVec2(writeUv), Vec4(depths.y));

			if(u_copyToClientLevel == 1u)
			{
				const U32 idx = writeUv.y * u_level1WriteImgSize.x + writeUv.x;
				u_clientBuf[idx] = depths.y;
			}
		}
	}
}

#pragma anki end
