<!-- 
Copyright (C) 2009-2018, Panagiotis Christopoulos Charitos and contributors.
All rights reserved.
Code licensed under the BSD License.
http://www.anki3d.org/LICENSE
-->
<shaderProgram>
	<shaders>
		<shader type="comp">
			<inputs>
				<input name="WORKGROUP_SIZE" type="uvec2" const="1"/>
			</inputs>

			<source><![CDATA[
#include "shaders/Functions.glsl"

layout(local_size_x = WORKGROUP_SIZE.x, local_size_y = WORKGROUP_SIZE.y, local_size_z = 1) in;

struct PushConsts
{
	uvec4 layerPad3;
};
ANKI_PUSH_CONSTANTS(PushConsts, u_regs);
#define u_layer u_regs.layerPad3.x

layout(ANKI_TEX_BINDING(0, 0)) uniform samplerCubeArray u_envTex;

#define SHCoefficients vec4
#define y00 x // Y l=0 m=0
#define y1n1 y // Y l=1 m=-1
#define y10 z  // Y l=1 m=0
#define y11 w  // Y l=1 m=1

layout(std140, ANKI_SS_BINDING(0, 0)) writeonly buffer _s0
{
	SHCoefficients u_SH[];
};
#define u_SHr u_SH[u_layer * 3u + 0u]
#define u_SHg u_SH[u_layer * 3u + 1u]
#define u_SHb u_SH[u_layer * 3u + 2u]

shared SHCoefficients s_scratch[3][WORKGROUP_SIZE.y * WORKGROUP_SIZE.x];

SHCoefficients computeSHCoeffiecients(vec3 dir)
{
	const float A = 0.282095;
	const float B = 0.488603;

	SHCoefficients sh;
	sh.y00 = A;
	sh.y1n1 = B * dir.y;
	sh.y10 = B * dir.z;
	sh.y11 = B * dir.x;
	return sh;
}

float areaElement(float x, float y)
{
	return atan(x * y, sqrt(x * x + y * y + 1.0));
}

float cubeCoordSolidAngle(vec2 norm)
{
	vec2 invSize = 1.0 / vec2(WORKGROUP_SIZE);
	vec2 v0 = norm - invSize;
	vec2 v1 = norm + invSize;
	return areaElement(v0.x, v0.y) - areaElement(v0.x, v1.y) - areaElement(v1.x, v0.y) + areaElement(v1.x, v1.y);
}

// Resolve the cube faces
void initPass()
{
	vec2 ndc = UV_TO_NDC(vec2(gl_LocalInvocationID.xy) / vec2(WORKGROUP_SIZE));

	SHCoefficients SHr = SHCoefficients(0.0);
	SHCoefficients SHg = SHCoefficients(0.0);
	SHCoefficients SHb = SHCoefficients(0.0);

	ANKI_LOOP for(uint face = 0u; face < 6u; ++face)
	{
		vec3 dir = getCubemapDirection(ndc, face);

		SHCoefficients sh = computeSHCoeffiecients(dir);
		vec3 rgb = textureLod(u_envTex, vec4(dir, u_layer), 10.0).rgb;

#if 1
		rgb = mix(rgb, textureLod(u_envTex, vec4(-dir, u_layer), 10.0).rgb, 0.10);
#endif

		SHr += rgb.r * sh;
		SHg += rgb.g * sh;
		SHb += rgb.b * sh;
	}

	float solidAngle = cubeCoordSolidAngle(ndc);
	uint idx = gl_LocalInvocationID.y * WORKGROUP_SIZE.x + gl_LocalInvocationID.x;

	s_scratch[0][idx] = SHr * solidAngle / PI;
	s_scratch[1][idx] = SHg * solidAngle / PI;
	s_scratch[2][idx] = SHb * solidAngle / PI;

	memoryBarrierShared();
	barrier();
}

// Reduce the result to a single vec4 per color component
void reducePasses()
{
	// Gather the results into one
	ANKI_UNROLL for(uint s = (WORKGROUP_SIZE.x * WORKGROUP_SIZE.y) / 2u; s > 0u; s >>= 1u)
	{
		if(gl_LocalInvocationIndex < s)
		{
			s_scratch[0][gl_LocalInvocationIndex] += s_scratch[0][gl_LocalInvocationIndex + s];
			s_scratch[1][gl_LocalInvocationIndex] += s_scratch[1][gl_LocalInvocationIndex + s];
			s_scratch[2][gl_LocalInvocationIndex] += s_scratch[2][gl_LocalInvocationIndex + s];
		}

		memoryBarrierShared();
		barrier();
	}
}

// Compute the final result
void resolvePass()
{
	if(gl_LocalInvocationIndex == 0)
	{
		u_SHr = s_scratch[0][0];
		u_SHg = s_scratch[1][0];
		u_SHb = s_scratch[2][0];
	}
}

void main()
{
	initPass();
	reducePasses();
	resolvePass();

	/*if(u_layer == 0)
		u_SHr = u_SHg = u_SHb = vec4(1.0, 0.0, 0.0, 0.0);
	else if(u_layer == 1)
		u_SHr = u_SHg = u_SHb = vec4(0.0, 1.0, 0.0, 0.0);
	else if(u_layer == 2)
		u_SHr = u_SHg = u_SHb = vec4(0.0, 0.0, 1.0, 0.0);
	else
		u_SHr = u_SHg = u_SHb = vec4(1.0, 0.0, 1.0, 0.0);*/


	/*u_SHr = vec4(1, 0, 1, 1);
		u_SHg = vec4(1, 0, 1, 1);
		u_SHb = vec4(1, 0, 1, 1);*/
}
			]]></source>
		</shader>
	</shaders>
</shaderProgram>